name: $(Date:yyyyMMdd)$(Rev:.r)-Platform
trigger: none
pr: none

parameters:
  - name: env
    displayName: Environment
    type: string
    values: [nonprod, prod]

  - name: action
    displayName: Action
    type: string
    default: deploy
    values: [deploy, destroy]

variables:
  TF_DIR: 'terraform'
  TF_VAR_FILE: '${{ parameters.env }}.tfvars'

  AWS_SERVICE_CONNECTION: 'yousif-aws-v2'
  AWS_REGION: 'ap-northeast-2'

  # SAME BACKEND AS INFRA PIPELINE
  TF_BACKEND_BUCKET: 'yousif-project-bucket'
  TF_BACKEND_KEY: '${{ parameters.env }}/terraform.tfstate'

pool:
  name: Yousif-Agent_Pool

jobs:
- job: Platform
  displayName: 'Platform Addons (Nginx, OAuth2-Proxy, Vault, ArgoCD, Sonar)'
  timeoutInMinutes: 180

  steps:
  - checkout: self
    fetchDepth: 1

  # --------------------------------------------------
  # 0) Terraform Init (Correct S3 Backend + Cache)
  # --------------------------------------------------
  - task: TerraformInstaller@1
    displayName: Install Terraform
    inputs:
      terraformVersion: latest

  - task: AWSShellScript@1
    displayName: Terraform init (S3 backend + cache)
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail
        cd "$(TF_DIR)"

        echo "Terraform version:"
        terraform -version

        # Use plugin cache if exists (self-hosted agent)
        if [ -f "$HOME/.terraformrc" ]; then
          export TF_CLI_CONFIG_FILE="$HOME/.terraformrc"
          echo "Using TF_CLI_CONFIG_FILE=$TF_CLI_CONFIG_FILE"
        fi

        export TF_PLUGIN_CACHE_DIR="${TF_PLUGIN_CACHE_DIR:-$HOME/.terraform.d/plugin-cache}"
        mkdir -p "$TF_PLUGIN_CACHE_DIR" || true

        echo "==> terraform init (S3 backend)"
        terraform init -reconfigure \
          -backend-config="bucket=$(TF_BACKEND_BUCKET)" \
          -backend-config="key=$(TF_BACKEND_KEY)" \
          -backend-config="region=$(AWS_REGION)" \
          -backend-config="encrypt=true"

  # --------------------------------------------------
  # 1) Configure kubeconfig
  # --------------------------------------------------
  - task: AWSShellScript@1
    displayName: Configure kubeconfig
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail
        cd "$(TF_DIR)"

        CLUSTER_NAME="$(terraform output -raw cluster_name 2>/dev/null || true)"
        if [ -z "$CLUSTER_NAME" ]; then
          echo "##[error]Could not read terraform output 'cluster_name'."
          terraform output || true
          exit 1
        fi

        echo "Updating kubeconfig for: $CLUSTER_NAME"
        aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$(AWS_REGION)"

        AWS_BIN="$(command -v aws || true)"
        if [ -n "$AWS_BIN" ]; then
          sed -i '' "s|command: aws|command: $AWS_BIN|g" "$HOME/.kube/config" || true
        fi

        kubectl get nodes

  # --------------------------------------------------
  # 2) Install Helm
  # --------------------------------------------------
  - task: HelmInstaller@1
    displayName: Install Helm
    inputs:
      helmVersionToInstall: 'latest'

  # ==================================================
  # ================= DEPLOY MODE ====================
  # ==================================================

  - task: AWSShellScript@1
    displayName: Deploy Nginx Ingress
    condition: and(succeeded(), eq('${{ parameters.action }}', 'deploy'))
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail

        helm upgrade --install ingress-nginx ingress-nginx \
          --repo https://kubernetes.github.io/ingress-nginx \
          --namespace ingress-nginx --create-namespace \
          --version 4.11.3 \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
          --set controller.admissionWebhooks.enabled=false \
          --wait --timeout 15m

  # --------------------------------------------------
  # Export Terraform outputs
  # --------------------------------------------------
  - task: AWSShellScript@1
    displayName: Export Terraform outputs
    condition: and(succeeded(), eq('${{ parameters.action }}', 'deploy'))
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail
        cd "$(TF_DIR)"

        COGNITO_CLIENT_ID="$(terraform output -raw cognito_client_id)"
        COGNITO_CLIENT_SECRET="$(terraform output -raw cognito_client_secret)"
        COGNITO_ISSUER_URL="$(terraform output -raw cognito_issuer_url)"
        APIGW_URL="$(terraform output -raw api_gateway_url)"

        COOKIE_SECRET="STABLE_SECRET_V1_FOR_32_BYTE_AES"

        echo "##vso[task.setvariable variable=COGNITO_CLIENT_ID;isSecret=true]$COGNITO_CLIENT_ID"
        echo "##vso[task.setvariable variable=COGNITO_CLIENT_SECRET;isSecret=true]$COGNITO_CLIENT_SECRET"
        echo "##vso[task.setvariable variable=COGNITO_ISSUER_URL]$COGNITO_ISSUER_URL"
        echo "##vso[task.setvariable variable=APIGW_URL]$APIGW_URL"
        echo "##vso[task.setvariable variable=COOKIE_SECRET;isSecret=true]$COOKIE_SECRET"

  # --------------------------------------------------
  # OAuth2 Proxy
  # --------------------------------------------------
  - task: AWSShellScript@1
    displayName: Deploy OAuth2-Proxy
    condition: and(succeeded(), eq('${{ parameters.action }}', 'deploy'))
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail

        helm upgrade --install oauth2-proxy oauth2-proxy \
          --repo https://oauth2-proxy.github.io/manifests \
          --namespace ingress-nginx --create-namespace \
          --wait --timeout 15m --atomic \
          --set config.clientID="$COGNITO_CLIENT_ID" \
          --set config.clientSecret="$COGNITO_CLIENT_SECRET" \
          --set config.cookieSecret="$COOKIE_SECRET" \
          --set extraArgs.provider="oidc" \
          --set extraArgs.oidc-issuer-url="$COGNITO_ISSUER_URL" \
          --set extraArgs.redirect-url="${APIGW_URL}/oauth2/callback"
    env:
      COGNITO_CLIENT_ID: $(COGNITO_CLIENT_ID)
      COGNITO_CLIENT_SECRET: $(COGNITO_CLIENT_SECRET)
      COOKIE_SECRET: $(COOKIE_SECRET)
      COGNITO_ISSUER_URL: $(COGNITO_ISSUER_URL)
      APIGW_URL: $(APIGW_URL)

  # --------------------------------------------------
  # DESTROY MODE
  # --------------------------------------------------
  - task: AWSShellScript@1
    displayName: Destroy platform add-ons
    condition: and(succeeded(), eq('${{ parameters.action }}', 'destroy'))
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail

        helm uninstall oauth2-proxy -n ingress-nginx || true
        helm uninstall ingress-nginx -n ingress-nginx || true

        kubectl delete ns ingress-nginx --ignore-not-found=true || true